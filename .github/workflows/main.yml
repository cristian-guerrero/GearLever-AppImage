name: Build GearLever AppImage

on:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 5 * * *' # 5 AM UTC daily
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-24.04 # Use a modern Ubuntu for GTK4/Libadwaita tools
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Build Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            meson ninja-build python3-gi python3-requests python3-xdg \
            python3-dbus python3-magic \
            python3-pip \
            libgtk-4-dev libadwaita-1-dev appstream desktop-file-utils \
            jq wget curl libfuse2 \
            gettext 7zip-standalone squashfs-tools

      - name: Download Source & Prepare
        id: prepare
        run: |
          REPO="mijorus/gearlever"
          API_URL="https://api.github.com/repos/$REPO/releases/latest"
          # Use GITHUB_TOKEN to avoid rate limits
          RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "$API_URL")
          VERSION=$(echo "$RESPONSE" | jq -r '.tag_name')
          URL=$(echo "$RESPONSE" | jq -r '.tarball_url')
          
          if [ "$VERSION" == "null" ] || [ -z "$VERSION" ]; then
            echo "Error: Could not fetch version from API"
            echo "Response: $RESPONSE"
            exit 1
          fi
          
          echo "Downloading version $VERSION from $URL"
          mkdir -p build/source
          curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" "$URL" -o build/gearlever.tar.gz
          tar -xzf build/gearlever.tar.gz -C build/source --strip-components=1
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Build and Install to AppDir
        run: |
          cd build/source
          meson setup _build --prefix=/usr
          DESTDIR=$GITHUB_WORKSPACE/build/GearLever.AppDir ninja -C _build install
          
          # Install get_appimage_offset script
          cp build-aux/get_appimage_offset.sh $GITHUB_WORKSPACE/build/GearLever.AppDir/usr/bin/get_appimage_offset
          chmod +x $GITHUB_WORKSPACE/build/GearLever.AppDir/usr/bin/get_appimage_offset
          
          # Bundle extraction tools
          cp $(which 7zz) $GITHUB_WORKSPACE/build/GearLever.AppDir/usr/bin/7zz
          cp $(which unsquashfs) $GITHUB_WORKSPACE/build/GearLever.AppDir/usr/bin/unsquashfs

      - name: Finalize AppDir
        run: |
          cd build
          APP_DIR="GearLever.AppDir"
          
          # 1. Create AppRun (Wrapper to handle libraries and Python environment)
          cat <<EOF > "$APP_DIR/AppRun"
          #!/bin/sh
          HERE="\$(dirname "\$(readlink -f "\${0}")")"
          
          # Portable Python Environment
          export PATH="\${HERE}/usr/bin:\${PATH}"
          export PYTHONHOME="\${HERE}/usr"
          export PYTHONPATH="\${HERE}/usr/share/gearlever:\${HERE}/usr/lib/python3.12:\${HERE}/usr/lib/python3/dist-packages:\${PYTHONPATH}"
          
          # GTK/GIO Portability
          export XDG_DATA_DIRS="\${HERE}/usr/share:\${XDG_DATA_DIRS:-/usr/local/share:/usr/share}"
          export GSETTINGS_SCHEMA_DIR="\${HERE}/usr/share/glib-2.0/schemas"
          export GI_TYPELIB_PATH="\${HERE}/usr/lib/x86_64-linux-gnu/girepository-1.0"
          
          # Use the bundled python from sharun
          if [ -f "\${HERE}/bin/python3" ]; then
            EXEC="\${HERE}/bin/python3"
          else
            EXEC="python3"
          fi
          
          # If run with --integrate-self, it tries to integration itself
          if [ "\$1" = "--integrate-self" ] && [ -n "\$APPIMAGE" ]; then
             exec "\$EXEC" "\${HERE}/usr/bin/gearlever" --integrate "\$APPIMAGE"
             exit 0
          fi
          
          exec "\$EXEC" "\${HERE}/usr/bin/gearlever" "\$@"
          EOF
          chmod +x "$APP_DIR/AppRun"
          
          # 2. Copy desktop file and icons to root
          echo "Debugging AppDir structure..."
          find "$APP_DIR" -maxdepth 4
          
          # Compile GSettings schemas (Crucial for GIO)
          if [ -d "$APP_DIR/usr/share/glib-2.0/schemas" ]; then
             echo "Compiling GSettings schemas..."
             glib-compile-schemas "$APP_DIR/usr/share/glib-2.0/schemas"
          fi
          
          cp "$APP_DIR/usr/share/applications/"*.desktop "$APP_DIR/gearlever.desktop"
          
          # Search everywhere for anything that looks like the app icon
          echo "Searching for icons..."
          ICON_PATH=$(find "$APP_DIR" -name "*gearlever*" -name "*.png" | head -n 1)
          if [ -z "$ICON_PATH" ]; then
            ICON_PATH=$(find "$APP_DIR" -name "*.png" | grep -v "appstream" | head -n 1)
          fi
          
          if [ -n "$ICON_PATH" ]; then
            echo "Icon found at: $ICON_PATH"
            cp "$ICON_PATH" "$APP_DIR/gearlever.png"
            # AppImage also likes having a copy in a common location
            mkdir -p "$APP_DIR/usr/share/icons/hicolor/512x512/apps"
            cp "$ICON_PATH" "$APP_DIR/usr/share/icons/hicolor/512x512/apps/gearlever.png"
          else
            echo "ERROR: No icon found in the entire AppDir!"
            exit 1
          fi
          
          sed -i 's/Icon=.*/Icon=gearlever/' "$APP_DIR/gearlever.desktop"
          echo "Desktop file Icon field set to gearlever"
          
          # 4. Patch hardcoded paths in the python entry point
          # Meson hardcodes /usr/share/gearlever based on the prefix. 
          # We need it to be relative to the AppImage mount point.
          GEARLEVER_BIN="$APP_DIR/usr/bin/gearlever"
          if [ -f "$GEARLEVER_BIN" ]; then
            echo "Patching hardcoded paths in $GEARLEVER_BIN"
            sed -i "s|pkgdatadir = '.*'|pkgdatadir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'share', 'gearlever'))|" "$GEARLEVER_BIN"
            sed -i "s|localedir = '.*'|localedir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'share', 'locale'))|" "$GEARLEVER_BIN"
          fi

      - name: Create AppImage
        run: |
          cd build
          
          # 1. Bundle Python Standard Library and essential site-packages
          # sharun bundles binaries, but we need the .py files for Python to function
          mkdir -p GearLever.AppDir/usr/lib/python3.12
          cp -ra /usr/lib/python3.12/. GearLever.AppDir/usr/lib/python3.12/
          
          # Also the dependencies installed via apt (gi, requests, xdg, dbus, magic)
          mkdir -p GearLever.AppDir/usr/lib/python3/dist-packages
          # Copy all installed dist-packages to ensure no missing dependencies
          cp -ra /usr/lib/python3/dist-packages/. GearLever.AppDir/usr/lib/python3/dist-packages/
          
          # Install missing dependencies from pip
          python3 -m pip install --target GearLever.AppDir/usr/lib/python3/dist-packages desktop-entry-lib ftputil
          
          # Bundle GObject Introspection typelibs (required for gi.require_version)
          mkdir -p GearLever.AppDir/usr/lib/x86_64-linux-gnu/girepository-1.0
          cp -ra /usr/lib/x86_64-linux-gnu/girepository-1.0/. GearLever.AppDir/usr/lib/x86_64-linux-gnu/girepository-1.0/
          
          # Use sharun to bundle everything: Python, GTK4, Libadwaita and their dependencies
          # This ensures the AppImage is standalone for immutable systems like NixOS/SteamOS
          wget -q https://github.com/VHSgunzo/sharun/releases/download/v0.7.9/sharun-x86_64 -O sharun
          chmod +x sharun
          
          # Bundle the python interpreter and its dependencies. 
          # We use lib4bin subcommand with the correct flags:
          # --dst-dir: The AppDir to bundle into
          # --with-hooks: Includes extra libraries like GIO/GTK modules
          # --hard-links: Creates a portable 'python3' launcher in GearLever.AppDir/bin/
          # We also explicitly bundle libadwaita/gtk4 as they are loaded via GI (dlopen)
          ./sharun lib4bin \
            --dst-dir GearLever.AppDir \
            --with-hooks \
            --hard-links \
            --verbose \
            /usr/bin/python3 \
            /usr/lib/x86_64-linux-gnu/libadwaita-1.so.0 \
            /usr/lib/x86_64-linux-gnu/libgtk-4.so.1 \
            $(which 7zz) \
            $(which unsquashfs)
          
          # Create AppImage
          wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage -O appimagetool
          chmod +x appimagetool
          
          export ARCH=x86_64
          export APPIMAGE_EXTRACT_AND_RUN=1
          
          REPO_OWNER=$(echo $GITHUB_REPOSITORY | cut -d'/' -f1)
          REPO_NAME=$(echo $GITHUB_REPOSITORY | cut -d'/' -f2)
          UPDATE_INFO="gh-releases-zsync|${REPO_OWNER}|${REPO_NAME}|latest|GearLever-x86_64.AppImage.zsync"
          
          ./appimagetool -u "$UPDATE_INFO" GearLever.AppDir GearLever-x86_64.AppImage

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.prepare.outputs.version }}
          name: GearLever ${{ steps.prepare.outputs.version }}
          body: |
            Automated build of GearLever AppImage.
            Use `./GearLever-x86_64.AppImage --integrate-self` to install it into your system using its own logic.
          files: build/*.AppImage*
          make_latest: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update Latest Tag
        uses: softprops/action-gh-release@v2
        with:
          tag_name: latest
          name: Latest Release
          body: "GearLever Version: ${{ steps.prepare.outputs.version }}"
          files: build/*.AppImage*
          prerelease: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
